/*
 * Copyright (c) 2008-2016, GigaSpaces Technologies, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.gigaspaces.internal.cluster.node;

import com.gigaspaces.internal.cluster.node.handlers.IReplicationInBatchConsumptionHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInDataTypeCreatedHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInDataTypeIndexAddedHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInEntryHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInEntryLeaseCancelledHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInEntryLeaseExpiredHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInEntryLeaseExtendedHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInEvictEntryHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInNotificationSentHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInNotifyTemplateCreatedHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInNotifyTemplateLeaseExpiredHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInNotifyTemplateLeaseExtendedHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInNotifyTemplateRemovedHandler;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInTransactionHandler;
import com.gigaspaces.internal.cluster.node.impl.directPersistency.DirectPersistencyBackupSyncIteratorHandler;
import com.gigaspaces.internal.cluster.node.impl.directPersistency.IDirectPersistencySyncHandler;
import com.gigaspaces.internal.cluster.node.replica.ISpaceCopyReplicaRequestContext;
import com.gigaspaces.internal.cluster.node.replica.ISpaceCopyReplicaState;
import com.gigaspaces.internal.cluster.node.replica.ISpaceCopyResult;
import com.gigaspaces.internal.cluster.node.replica.ISpaceSynchronizeReplicaRequestContext;
import com.gigaspaces.internal.cluster.node.replica.ISpaceSynchronizeReplicaState;
import com.gigaspaces.internal.metadata.ITypeDesc;
import com.gigaspaces.internal.server.storage.IEntryHolder;
import com.gigaspaces.internal.server.storage.NotifyTemplateHolder;
import com.gigaspaces.internal.space.requests.AddTypeIndexesRequestInfo;
import com.j_spaces.core.OperationID;
import com.j_spaces.core.cache.blobStore.BlobStoreReplicaConsumeHelper;
import com.j_spaces.core.cache.blobStore.BlobStoreReplicationBulkConsumeHelper;

import net.jini.core.transaction.server.ServerTransaction;

import java.util.ArrayList;


/**
 * The interaction point between a single space instance and a cluster of spaces
 *
 * @author eitany
 * @since 8.0
 */
public interface IReplicationNode {
    /**
     * Notify replication node that a new entry was written
     *
     * @param context     the context of the operation
     * @param entryHolder written entry
     */
    void outWriteEntry(IReplicationOutContext context, IEntryHolder entryHolder);

    /**
     * Sets a handler for incoming write entry replication event which was generated by a different
     * node as a result of {@link #outWriteEntry(IReplicationOutContext, IEntryHolder)}
     */
    void setInEntryHandler(IReplicationInEntryHandler handler);

    /**
     * Notify replication node that an entry was updated
     *
     * @param context     the context of the operation
     * @param entryHolder updated entry
     */
    void outUpdateEntry(IReplicationOutContext context, IEntryHolder entryHolder);

    /**
     * Notify replication node that an entry was changed
     *
     * @param context     the context of the operation
     * @param entryHolder mutated entry
     * @since 9.1
     */
    void outChangeEntry(IReplicationOutContext context, IEntryHolder entryHolder);

    /**
     * Notify replication node that an entry was removed
     *
     * @param context     the context of the operation
     * @param entryHolder removed entry
     */
    void outRemoveEntry(IReplicationOutContext context, IEntryHolder entryHolder);

    /**
     * Notify replication node that an entry lease was canceled
     *
     * @param context     the context of the operation
     * @param entryHolder entry of which its lease was canceled
     */
    void outCancelEntryLease(IReplicationOutContext context,
                             IEntryHolder entryHolder);

    /**
     * Notify replication node that an entry lease expired
     *
     * @param context     the context of the operation
     * @param entryHolder entry of which its lease expired
     */
    void outEntryLeaseExpired(IReplicationOutContext context,
                              IEntryHolder entryHolder);


    /**
     * Sets a handler for incoming cancel entry lease replication event which was generated by a
     * different node as a result of {@link #outCancelEntryLease(IReplicationOutContext,
     * IEntryHolder)}
     */
    void setInEntryLeaseCancelledHandler(
            IReplicationInEntryLeaseCancelledHandler handler);

    /**
     * Sets a handler for incoming entry lease expired replication event which was generated by a
     * different node as a result of {@link #outCancelEntryLease(IReplicationOutContext,
     * IEntryHolder)}
     */
    void setInEntryLeaseExpiredHandler(
            IReplicationInEntryLeaseExpiredHandler handler);

    /**
     * Notify replication node that an entry was evicted
     *
     * @param context     the context of the operation
     * @param entryHolder evicted entry
     */
    void outEvictEntry(IReplicationOutContext context, IEntryHolder entryHolder);

    /**
     * Sets a handler for incoming evict entry replication event which was generated by a different
     * node as a result of {@link #outEvictEntry(IReplicationOutContext, IEntryHolder)}
     */
    void setInEvictEntryHandler(IReplicationInEvictEntryHandler handler);

    /**
     * Notify replication node that a new notify template was inserted
     *
     * @param context        the context of the operation
     * @param templateHolder inserted template
     */
    void outInsertNotifyTemplate(IReplicationOutContext context,
                                 NotifyTemplateHolder templateHolder);

    /**
     * Sets a handler for incoming insert notify template replication event which was generated by a
     * different node as a result of {@link #outInsertNotifyTemplate(IReplicationOutContext,
     * NotifyTemplateHolder)}
     */
    void setInNotifyTemplateCreatedHandler(
            IReplicationInNotifyTemplateCreatedHandler handler);
//YP

    /**
     * Notify replication node that a notify template was removed
     *
     * @param context        the context of the operation
     * @param templateHolder removed template
     */
    void outRemoveNotifyTemplate(IReplicationOutContext context,
                                 NotifyTemplateHolder templateHolder);

    /**
     * Sets a handler for incoming remove notify template replication event which was generated by a
     * different node as a result of {@link #outRemoveNotifyTemplate(IReplicationOutContext,
     * NotifyTemplateHolder)}
     */
    void setInNotifyTemplateRemovedHandler(
            IReplicationInNotifyTemplateRemovedHandler handler);

    /**
     * Notify replication node that an notify template lease expired
     *
     * @param context        the context of the operation
     * @param templateHolder of which its lease expired
     */
    void outNotifyTemplateLeaseExpired(IReplicationOutContext context,
                                       NotifyTemplateHolder templateHolder);

    /**
     * Sets a handler for incoming notify-template lease expired replication event which was
     * generated by a different node as a result of {@link #outNotifyTemplateLeaseExpired(IReplicationOutContext,
     * NotifyTemplateHolder)}
     */
    void setInNotifyTemplateLeaseExpiredHandler(
            IReplicationInNotifyTemplateLeaseExpiredHandler handler);


    /**
     * Notify replication node that an entry lease is extended
     *
     * @param context the context of the operation
     */
    void outExtendEntryLeasePeriod(IReplicationOutContext context, IEntryHolder entryHolder);

    /**
     * Sets a handler for incoming extend lease replication event which was generated by a different
     * node as a result of {@link #outExtendNotifyTemplateLeasePeriod(IReplicationOutContext,
     * IEntryHolder)}
     */
    void setInNotifyTemplateLeaseExtendedHandler(IReplicationInNotifyTemplateLeaseExtendedHandler handler);

    /**
     * Notify replication node that a notify template lease is extended
     *
     * @param context the context of the operation
     */
    void outExtendNotifyTemplateLeasePeriod(IReplicationOutContext context, NotifyTemplateHolder entryHolder);

    /**
     * Sets a handler for incoming extend lease replication event which was generated by a different
     * node as a result of {@link #outExtendEntryLeasePeriod(IReplicationOutContext, IEntryHolder)}
     */
    void setInEntryLeaseExtendedHandler(IReplicationInEntryLeaseExtendedHandler handler);

    /**
     * Notify replication node that a transaction is executed in one stage (one phase commit)
     *
     * @param transaction   executed transaction
     * @param lockedEntries entries participating in the transaction and their corresponding
     *                      operation
     */
    void outTransaction(IReplicationOutContext context,
                        ServerTransaction transaction,
                        ArrayList<IEntryHolder> lockedEntries);

    /**
     * Notify replication node that a transaction prepare is executed (two phase commit)
     *
     * @param transaction   prepared transaction
     * @param lockedEntries entries participating in the transaction and their corresponding
     *                      operation
     */
    void outTransactionPrepare(IReplicationOutContext context,
                               ServerTransaction transaction,
                               ArrayList<IEntryHolder> lockedEntries);

    /**
     * Notify replication node that a transaction commit is executed (two phase commit)
     *
     * @param transaction committed transaction
     */
    void outTransactionCommit(IReplicationOutContext context,
                              ServerTransaction transaction);

    /**
     * Notify replication node that a transaction abort is executed (two phase commit)
     *
     * @param transaction committed transaction
     */
    void outTransactionAbort(IReplicationOutContext context,
                             ServerTransaction transaction);

    /**
     * Sets a handler for incoming transaction replication event which was generated by a different
     * node as a result of {@link #outTransaction(IReplicationOutContext, ServerTransaction,
     * ArrayList<EntryCacheInfo>)}
     */
    void setInTransactionHandler(IReplicationInTransactionHandler handler);

    /**
     * Notify and dispatch the replication event representing that a notification was sent
     * successfully
     *
     * @param OperationID the operation Id of the event
     */
    void outNotificationSentAndExecute(OperationID operationId);

    /**
     * Notify the replication node that new data type was introduced
     *
     * @param typeDescriptor the updated type descriptor
     */
    void outDataTypeIntroduce(IReplicationOutContext context, ITypeDesc typeDescriptor);

    /**
     * Notify the replication node that new index was added to this data type
     */
    void outDataTypeAddIndex(IReplicationOutContext context, AddTypeIndexesRequestInfo addIndexesRequest);

    /**
     * Sets a handler for incoming data type replication event which was generated by a different
     * node as a result of {@link #outDataTypeIntroduce(IReplicationOutContext, ITypeDesc)}
     */
    void setInDataTypeCreatedHandler(IReplicationInDataTypeCreatedHandler handler);

    /**
     * Sets a handler for incoming data type add index replication event which was generated by a
     * different node as a result of {@link #outDataTypeIntroduce(IReplicationOutContext,
     * ITypeDesc)}
     */
    void setInDataTypeIndexAddedHandler(IReplicationInDataTypeIndexAddedHandler handler);

    /**
     * Sets a handler for incoming notification sent event which was generated by a different node
     * as a result of {@link #outNotificationSentAndExecute(OperationID)}
     */
    void setInNotificationSentHandler(
            IReplicationInNotificationSentHandler handler);

    /**
     * Sets a handler for incoming replication upon batch consumption completion
     */
    void setInBatchConsumptionHandler(IReplicationInBatchConsumptionHandler handler);

    /**
     * @return create a replication out context
     */
    IReplicationOutContext createContext();

    /**
     * Executes the accumulated replication according to the given context
     *
     * @param replicationContext replication context
     * @return true number of completed replications.
     */
    int execute(IReplicationOutContext replicationContext);

    /**
     * @return administrator of the replication node
     */
    IReplicationNodeAdmin getAdmin();

    /**
     * Starts a space synchronize replica request, will copy the current state of a remote space and
     * synchronize with ongoing changes, the synchronization can only occurr if the target space has
     * replication channel to this space (Recovery).
     *
     * @return space synchronize replica state representing the current progress of the
     * synchronization
     */
    ISpaceSynchronizeReplicaState spaceSynchronizeReplicaRequest(
            ISpaceSynchronizeReplicaRequestContext context);

    /**
     * Starts a space copy replica request, will copy the current state of a remote space. Should be
     * used when the target space is in a static state, meaning its data state do not change during
     * the copy, otherwise the copy result is not guaranteed to be an exact replica of the target
     * space (Offline copy, for admin purposes).
     *
     * @return space copy replica state representing the current progress of the copy operation
     */
    ISpaceCopyReplicaState spaceCopyReplicaRequest(
            ISpaceCopyReplicaRequestContext context);

    void rollbackCopyReplica(ISpaceCopyResult replicaResult);


    /*
      blobStoreReplicaHelper provides bluking help in case of replication recovery
      */
    void setBlobStoreReplicaConsumeHelper(BlobStoreReplicaConsumeHelper blobStoreReplicaHelper);

    /*
      blobStoreReplicaHelper provides bluking help in case of replication recovery
      */
    BlobStoreReplicaConsumeHelper getBlobStoreReplicaConsumeHelper();

    /*
   handles direct persistency consistency
   */
    IDirectPersistencySyncHandler getDirectPesistencySyncHandler();

    DirectPersistencyBackupSyncIteratorHandler getDirectPersistencyBackupSyncIteratorHandler();

    void setDirectPersistencyBackupSyncIteratorHandler(DirectPersistencyBackupSyncIteratorHandler directPersistencyBackupSyncIteratorHandler);

    /**
     * Closes the node, once closed the node is no longer usable.
     */
    void close();

    void setBlobStoreReplicationBulkConsumeHelper(BlobStoreReplicationBulkConsumeHelper blobStoreReplicationBulkConsumeHelper);

    BlobStoreReplicationBulkConsumeHelper getBlobStoreReplicationBulkConsumeHelper();

    void outDataTypeDrop(IReplicationOutContext context, String className);
}
